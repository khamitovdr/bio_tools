{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the BioExperiment Suite parts you can use in your applications.</p> <p>If you are looking for a specific part of the API, you can use the search bar at the top of the page.</p> <p>To learn how to use the API, you can check the examples page.</p>"},{"location":"api/tools/","title":"Helper functions for working with COM peripheral devices","text":""},{"location":"api/tools/#src.bioexperiment_suite.tools.serial_port.get_serial_ports","title":"<code>get_serial_ports()</code>","text":"<p>Lists serial port names on the system.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of the serial ports available on the system</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>On unsupported or unknown platforms</p> Source code in <code>src/bioexperiment_suite/tools/serial_port.py</code> <pre><code>def get_serial_ports() -&gt; list[str]:\n    \"\"\"Lists serial port names on the system.\n\n    :returns: A list of the serial ports available on the system\n\n    :raises EnvironmentError: On unsupported or unknown platforms\n    \"\"\"\n    if sys.platform.startswith(\"win\"):\n        logger.info(\"Windows platform detected\")\n        ports = [f\"COM{i + 1}\" for i in range(256)]\n    elif sys.platform.startswith(\"linux\") or sys.platform.startswith(\"cygwin\"):\n        logger.info(\"Linux platform detected\")\n        # this excludes your current terminal \"/dev/tty\"\n        ports = glob.glob(\"/dev/tty[A-Za-z]*\")\n    elif sys.platform.startswith(\"darwin\"):\n        logger.info(\"MacOS platform detected\")\n        ports = glob.glob(\"/dev/tty.*\")\n    else:\n        logger.error(f\"Unsupported platform: {sys.platform}\")\n        raise EnvironmentError(\"Unsupported platform\")\n\n    if get_settings().EMULATE_DEVICES:\n        logger.info(\"Emulating devices\")\n        pumps_port_numbers = [i * 2 for i in range(get_settings().N_VIRTUAL_PUMPS)]\n        spectrophotometers_port_numbers = [i * 2 + 1 for i in range(get_settings().N_VIRTUAL_SPECTROPHOTOMETERS)]\n        result = [f\"COM{i}\" for i in sorted(pumps_port_numbers + spectrophotometers_port_numbers)]\n        logger.debug(f\"Fake serial ports found: {result}\")\n        return result\n\n    result = []\n    for port in ports:\n        try:\n            s = serial.Serial(port)\n            s.close()\n            result.append(port)\n        except (OSError, serial.SerialException):\n            pass\n\n    return result\n</code></pre>"},{"location":"api/tools/#src.bioexperiment_suite.tools.devices.identify_device","title":"<code>identify_device(port)</code>","text":"<p>Identifies the device connected to the specified serial port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port name to identify the device connected to</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The device name of the device connected to the specified serial port, None otherwise</p> Source code in <code>src/bioexperiment_suite/tools/devices.py</code> <pre><code>def identify_device(port: str) -&gt; str | None:\n    \"\"\"Identifies the device connected to the specified serial port.\n\n    :param port: The serial port name to identify the device connected to\n\n    :returns: The device name of the device connected to the specified serial port, None otherwise\n    \"\"\"\n    if get_settings().EMULATE_DEVICES:\n        device_names = [\"pump\", \"spectrophotometer\"]\n        port_number = int(port[-1])\n        return device_names[port_number % 2]\n\n    serial_connection = SerialConnection(port)\n    for device_name, device_interface in device_interfaces.items():\n        logger.debug(f'Checking for device \"{device_interface.type}\" on port {port}')\n        logger.debug(f\"Identification signal: {device_interface.identification_signal}\")\n        response = serial_connection.communicate_with_serial_port(\n            device_interface.identification_signal, device_interface.identification_response_len\n        )\n\n        if len(response) == device_interface.identification_response_len and list(response)[0] == int(\n            device_interface.first_identification_response_byte\n        ):\n            logger.success(f'Device \"{device_interface.type}\" identified on port {port}')\n            return device_name\n\n    logger.warning(f\"No device identified on port {port}\")\n    return None\n</code></pre>"},{"location":"api/tools/#src.bioexperiment_suite.tools.devices.get_connected_devices","title":"<code>get_connected_devices()</code>","text":"<p>Identifies the devices connected to the serial ports on the system.</p> <p>Returns:</p> Type Description <code>tuple[list[Pump], list[Spectrophotometer]]</code> <p>A tuple containing the list of connected pumps and spectrophotometers</p> Source code in <code>src/bioexperiment_suite/tools/devices.py</code> <pre><code>def get_connected_devices() -&gt; tuple[list[Pump], list[Spectrophotometer]]:\n    \"\"\"Identifies the devices connected to the serial ports on the system.\n\n    :returns: A tuple containing the list of connected pumps and spectrophotometers\n    \"\"\"\n    serial_ports = get_serial_ports()\n    pump_list = []\n    spectrophotometer_list = []\n    for port in serial_ports:\n        device = identify_device(port)\n\n        match device:\n            case \"pump\":\n                pump = Pump(port)\n                pump_list.append(pump)\n            case \"spectrophotometer\":\n                spectrophotometer = Spectrophotometer(port)\n                spectrophotometer_list.append(spectrophotometer)\n\n    return pump_list, spectrophotometer_list\n</code></pre>"},{"location":"api/experiment/","title":"Experiment","text":"<p>This module provides the class for creating and running biological experiments. An experiment is a sequence of actions including:</p> <ul> <li>Actions (e.g. pump liquid)</li> <li>Measurements (e.g. measure optical density)</li> <li>Waiting (wait for a certain amount of time)</li> </ul> <p>After setting up an experiment, you can run it and the BioExperiment Suite will execute the actions in the order you specified. Then you can analyze the results.</p>"},{"location":"api/experiment/actions/","title":"Actions","text":""},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action","title":"<code>Action</code>","text":"<p>Class to define an action to be executed in an experiment.</p> <p>The action can be executed with the <code>execute</code> method, which will call the function with the provided arguments. The action keeps track of the time it was started and completed.</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>class Action:\n    \"\"\"Class to define an action to be executed in an experiment.\n\n    The action can be executed with the `execute` method, which will call the function with the provided arguments.\n    The action keeps track of the time it was started and completed.\n    \"\"\"\n\n    def __init__(self, func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the action with the function to be executed and the arguments to be passed to it.\n\n        :param func: The function to be executed\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.start_time: datetime | None = None\n        self.end_time: datetime | None = None\n        logger.debug(f\"Action created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the action by calling the function with the provided arguments and tracking the start and end time.\"\"\"\n        self.start_time = datetime.now()\n        logger.debug(f\"Executing action: {self.func.__name__}\")\n        self.func(*self.args, **self.kwargs)\n        self.end_time = datetime.now()\n        logger.debug(f\"Action completed: {self.func.__name__}\")\n\n    def is_completed(self) -&gt; bool:\n        \"\"\"Check if the action has been completed.\n\n        :return: True if the action has been completed, False otherwise\n        \"\"\"\n        return self.end_time is not None and self.start_time is not None\n\n    def duration(self) -&gt; timedelta:\n        \"\"\"Get the duration of the action.\n\n        :return: The duration of the action as a timedelta\n\n        :raises ValueError: If the action has not been completed yet\n        \"\"\"\n        if not self.is_completed():\n            raise ValueError(\"Action did not complete yet\")\n\n        return self.end_time - self.start_time  # type: ignore\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.__init__","title":"<code>__init__(func, *args, **kwargs)</code>","text":"<p>Initialize the action with the function to be executed and the arguments to be passed to it.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def __init__(self, func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the action with the function to be executed and the arguments to be passed to it.\n\n    :param func: The function to be executed\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self.func = func\n    self.args = args\n    self.kwargs = kwargs\n    self.start_time: datetime | None = None\n    self.end_time: datetime | None = None\n    logger.debug(f\"Action created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.execute","title":"<code>execute()</code>","text":"<p>Execute the action by calling the function with the provided arguments and tracking the start and end time.</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def execute(self) -&gt; None:\n    \"\"\"Execute the action by calling the function with the provided arguments and tracking the start and end time.\"\"\"\n    self.start_time = datetime.now()\n    logger.debug(f\"Executing action: {self.func.__name__}\")\n    self.func(*self.args, **self.kwargs)\n    self.end_time = datetime.now()\n    logger.debug(f\"Action completed: {self.func.__name__}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.is_completed","title":"<code>is_completed()</code>","text":"<p>Check if the action has been completed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the action has been completed, False otherwise</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def is_completed(self) -&gt; bool:\n    \"\"\"Check if the action has been completed.\n\n    :return: True if the action has been completed, False otherwise\n    \"\"\"\n    return self.end_time is not None and self.start_time is not None\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.duration","title":"<code>duration()</code>","text":"<p>Get the duration of the action.</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>The duration of the action as a timedelta</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action has not been completed yet</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def duration(self) -&gt; timedelta:\n    \"\"\"Get the duration of the action.\n\n    :return: The duration of the action as a timedelta\n\n    :raises ValueError: If the action has not been completed yet\n    \"\"\"\n    if not self.is_completed():\n        raise ValueError(\"Action did not complete yet\")\n\n    return self.end_time - self.start_time  # type: ignore\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement","title":"<code>Measurement</code>","text":"<p>               Bases: <code>Action</code></p> <p>Class to define a measurement to be executed in an experiment.</p> <p>The measurement is a special type of action that also stores the measured value name and the measurement result.</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>class Measurement(Action):\n    \"\"\"Class to define a measurement to be executed in an experiment.\n\n    The measurement is a special type of action that also stores the measured value name and the measurement result.\n    \"\"\"\n\n    def __init__(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n        \"\"\"Initialize the measurement with the function to be executed, the measured value name, and the arguments.\n\n        :param func: The function to be executed\n        :param measurement_name: The name of the measured value\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        super().__init__(func, *args, **kwargs)\n        self.measurement_name = measurement_name\n        self.measured_value = None\n        logger.debug(f\"Measurement created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n\n    def execute(self) -&gt; Any:\n        \"\"\"Execute the measurement by calling the function with the provided arguments and tracking the start and end time.\n\n        :return: The result of the measurement\n        \"\"\"\n        assert self.start_time is None, \"Measurement already executed\"\n        self.start_time = datetime.now()\n        logger.debug(f\"Executing measurement: {self.func.__name__}\")\n        result = self.func(*self.args, **self.kwargs)\n        self.end_time = datetime.now()\n        self.measured_value = result\n        logger.debug(f\"Measurement completed: {self.func.__name__}\")\n        return result\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement.__init__","title":"<code>__init__(func, measurement_name, *args, **kwargs)</code>","text":"<p>Initialize the measurement with the function to be executed, the measured value name, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>measurement_name</code> <code>str</code> <p>The name of the measured value</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def __init__(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n    \"\"\"Initialize the measurement with the function to be executed, the measured value name, and the arguments.\n\n    :param func: The function to be executed\n    :param measurement_name: The name of the measured value\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    super().__init__(func, *args, **kwargs)\n    self.measurement_name = measurement_name\n    self.measured_value = None\n    logger.debug(f\"Measurement created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement.execute","title":"<code>execute()</code>","text":"<p>Execute the measurement by calling the function with the provided arguments and tracking the start and end time.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the measurement</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def execute(self) -&gt; Any:\n    \"\"\"Execute the measurement by calling the function with the provided arguments and tracking the start and end time.\n\n    :return: The result of the measurement\n    \"\"\"\n    assert self.start_time is None, \"Measurement already executed\"\n    self.start_time = datetime.now()\n    logger.debug(f\"Executing measurement: {self.func.__name__}\")\n    result = self.func(*self.args, **self.kwargs)\n    self.end_time = datetime.now()\n    self.measured_value = result\n    logger.debug(f\"Measurement completed: {self.func.__name__}\")\n    return result\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.WaitAction","title":"<code>WaitAction</code>","text":"<p>Class to define a wait action to be executed in an experiment.</p> <p>The wait action is a special type of action that pauses the execution of the experiment for a given amount of time. If some action takes time to be executed, the wait time should be not less than the time taken by the action.</p> Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>class WaitAction:\n    \"\"\"Class to define a wait action to be executed in an experiment.\n\n    The wait action is a special type of action that pauses the execution of the experiment for a given amount of time.\n    If some action takes time to be executed, the wait time should be not less than the time taken by the action.\n    \"\"\"\n\n    def __init__(self, seconds: float):\n        \"\"\"Initialize the wait action with the number of seconds to wait.\n\n        :param seconds: The number of seconds to wait\n        \"\"\"\n        self.wait_time: timedelta = timedelta(seconds=seconds)\n        logger.debug(f\"Wait action created: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.WaitAction.__init__","title":"<code>__init__(seconds)</code>","text":"<p>Initialize the wait action with the number of seconds to wait.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds to wait</p> required Source code in <code>src/bioexperiment_suite/experiment/actions.py</code> <pre><code>def __init__(self, seconds: float):\n    \"\"\"Initialize the wait action with the number of seconds to wait.\n\n    :param seconds: The number of seconds to wait\n    \"\"\"\n    self.wait_time: timedelta = timedelta(seconds=seconds)\n    logger.debug(f\"Wait action created: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/experiment/","title":"Experiment","text":""},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>Class to define an experiment with actions and measurements to be executed in sequence.</p> <p>The experiment can be run with the <code>run</code> method, which will execute each action in sequence. The experiment keeps track of the time each action was executed and the measurements taken.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>class Experiment:\n    \"\"\"Class to define an experiment with actions and measurements to be executed in sequence.\n\n    The experiment can be run with the `run` method, which will execute each action in sequence.\n    The experiment keeps track of the time each action was executed and the measurements taken.\n    \"\"\"\n\n    def __init__(self, output_dir: os.PathLike | None = None, output_socket_port: int | None = None):\n        \"\"\"Initialize the experiment with an empty list of actions and measurements\"\"\"\n        self.actions: list[Action | WaitAction | ConditionalAction] = []\n        self.measurements: dict[str, list[tuple[datetime, Any]]] = defaultdict(list)\n        self.current_time: datetime | None = (\n            None  # Time to keep track of the experiment progress. Initializes on start.\n        )\n        self.output_dir = output_dir\n        self.output_socket_port = output_socket_port\n        self._thread: Thread | None = None\n        self._stop_event = Event()\n        self._websocket_clients: set[WebSocketServerProtocol] = set()\n        self._websocket_server = None\n        self._websocket_thread: Thread | None = None\n        self._websocket_loop: asyncio.AbstractEventLoop | None = None\n        logger.debug(\"Experiment created\")\n\n    def create_metric(self, measurement_name: str, statistic: Statistic | None = Statistic.LAST()) -&gt; Metric:\n        \"\"\"Create a metric object to be used in the experiment for making dynamic decisions.\n\n        :param measurement_name: The name of the measurement in the experiment to use for the metric calculation\n        :param statistic: The statistic to apply to the measurement values\n\n        :return: The metric object\n        \"\"\"\n        return Metric(self, measurement_name, statistic)\n\n    def specify_output_dir(self, output_dir: os.PathLike):\n        \"\"\"Specify the output directory to write measurements to CSV files.\n\n        :param output_dir: The directory to write measurements to\n        \"\"\"\n        self.output_dir = output_dir\n        logger.debug(f\"Output directory specified: {output_dir}\")\n\n    def specify_output_socket_port(self, port: int):\n        \"\"\"Specify the output socket port to stream measurements via websocket.\n\n        :param port: The port number to use for the websocket server\n        \"\"\"\n        self.output_socket_port = port\n        logger.debug(f\"Output socket port specified: {port}\")\n\n    def add_action(self, func: Callable, condition: Condition | None = None, *args: Any, **kwargs: Any):\n        \"\"\"Add an action to the experiment.\n\n        The action will be executed in sequence when the experiment is run.\n\n        :param func: The function to be executed\n        :param condition: The condition to evaluate before executing the action\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self._validate_types(func, *args, **kwargs)\n        action = Action(func, *args, **kwargs)\n        if condition is not None:\n            self.actions.append(ConditionalAction(action, condition))\n            logger.debug(f\"Conditional action added to experiment: {func.__name__} with condition: {condition}\")\n            return\n\n        self.actions.append(action)\n        logger.debug(f\"Action added to experiment: {func.__name__}\")\n\n    def add_measurement(\n        self, func: Callable, measurement_name: str, condition: Condition | None = None, *args: Any, **kwargs: Any\n    ):\n        \"\"\"Add a measurement to the experiment.\n\n        The measurement will be executed in sequence when the experiment is run, and the result will be stored.\n\n        :param func: The function to be executed\n        :param measurement_name: The name of the measured value\n        :param condition: The condition to evaluate before executing the action\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self._validate_types(func, *args, **kwargs)\n        measurement = Measurement(func, measurement_name, *args, **kwargs)\n        if condition is not None:\n            self.actions.append(ConditionalAction(measurement, condition))\n            logger.debug(f\"Conditional measurement added to experiment: {func.__name__} with condition: {condition}\")\n            return\n\n        self.actions.append(measurement)\n        logger.debug(f\"Measurement added to experiment: {func.__name__}\")\n\n    def add_wait(self, seconds: float, condition: Condition | None = None):\n        \"\"\"Add a wait action to the experiment.\n\n        The wait action will pause the execution of the experiment for the given amount of time.\n\n        :param seconds: The number of seconds to wait\n        :param condition: The condition to evaluate before executing the action\n        \"\"\"\n        wait_action = WaitAction(seconds)\n        if condition is not None:\n            self.actions.append(ConditionalAction(wait_action, condition))\n            logger.debug(f\"Conditional wait added to experiment: {seconds} seconds with condition: {condition}\")\n            return\n\n        self.actions.append(wait_action)\n        logger.debug(f\"Wait action added to experiment: {seconds} seconds\")\n\n    def _perform_action(self, action: Action | WaitAction | ConditionalAction, step: int) -&gt; bool:\n        \"\"\"Perform the action by executing it or waiting for the specified time.\n\n        :param action: The action to perform\n        \"\"\"\n        logger.debug(f\"Step {step + 1} from {len(self.actions)}\")\n        if isinstance(action, Measurement):\n            logger.debug(f\"Executing measurement: {action.func.__name__}\")\n            action.execute()\n            self.measurements[action.measurement_name].append((datetime.now(), action.measured_value))\n            self.write_measurement_to_csv(action.measurement_name)\n            self.write_measurements_to_socket(action.measurement_name)\n        elif isinstance(action, Action):\n            logger.debug(f\"Executing action: {action.func.__name__}\")\n            action.execute()\n        elif isinstance(action, WaitAction):\n            wait_until = self.current_time + action.wait_time\n            logger.debug(f\"Waiting for {action.wait_time.total_seconds()} seconds from {self.current_time}\")\n\n            if datetime.now() &gt; wait_until:\n                logger.warning(f\"Wait time exceeded on step {step + 1} by {datetime.now() - wait_until}\")\n\n            while datetime.now() &lt; wait_until:\n                if self._stop_event.is_set():\n                    logger.debug(\"Experiment stopped\")\n                    return False\n                time.sleep(0.1)\n\n            self.current_time += action.wait_time\n\n        elif isinstance(action, ConditionalAction):\n            action_to_execute = action.get_action()\n            if action_to_execute is not None:\n                self._perform_action(action_to_execute, step)\n            else:\n                logger.debug(\"Condition not met, skipping action\")\n\n        else:\n            logger.error(f\"Unknown action type: {type(action)}\")\n            raise ValueError(f\"Unknown action type: {type(action)}\")\n\n        return True\n\n    def _run(self):\n        \"\"\"Run the experiment by executing each action in sequence.\"\"\"\n        self.current_time = datetime.now()\n        logger.debug(f\"Experiment started. Start time: {self.current_time}\")\n        for step, action in enumerate(self.actions):\n            if not self._perform_action(action, step):\n                return\n\n    def start(self, start_in_background: bool = True):\n        \"\"\"Start the experiment by running it in idle mode or in a separate thread depending on the `start_in_background` flag.\n\n        :param start_in_background: If True, start the experiment in a separate thread.\n        If False, run the experiment in the current thread. Be careful with this option,\n        as it will block the current thread until the experiment is finished!\n        \"\"\"\n        if self._thread is not None:\n            logger.warning(\"Experiment is already running\")\n            return\n\n        self._stop_event.clear()\n\n        # Start websocket server if port is specified\n        if self.output_socket_port is not None:\n            self._websocket_thread = Thread(target=self._start_websocket_server, daemon=True)\n            self._websocket_thread.start()\n            # Give the websocket server a moment to start\n            time.sleep(0.5)\n\n        if start_in_background:\n            self._thread = Thread(target=self._run)\n            self._thread.start()\n        else:\n            self._run()\n\n    def stop(self):\n        \"\"\"Stop the experiment by setting the stop event.\"\"\"\n        if self._thread is None:\n            logger.warning(\"Experiment is not running\")\n            return\n        self._stop_event.set()\n        logger.info(\"Experiment stop signal sent\")\n\n        # Stop websocket server\n        if self.output_socket_port is not None:\n            self._stop_websocket_server()\n\n    def write_measurement_to_csv(self, measurement_name: str):\n        \"\"\"Write last acquired measurement to a CSV file.\n\n        :param measurement_name: The name of the measurement to write to a CSV file\n        \"\"\"\n        if self.output_dir is None:\n            return\n\n        if measurement_name not in self.measurements:\n            raise ValueError(f\"Measurement '{measurement_name}' not found\")\n\n        output_file = os.path.join(self.output_dir, f\"{measurement_name}.csv\")\n        with open(output_file, \"a\") as f:\n            timestamp, value = self.measurements[measurement_name][-1]\n            f.write(f\"{timestamp},{value}\\n\")\n\n        logger.debug(f\"Measurement '{measurement_name}' written to {output_file}\")\n\n    def write_measurements_to_socket(self, measurement_name: str):\n        \"\"\"Write all acquired measurements to a websocket.\n\n        :param measurement_name: The name of the measurement to write to a websocket\n        \"\"\"\n        if self.output_socket_port is None:\n            return\n\n        if not self._websocket_clients:\n            return\n\n        # Format measurements as requested: {measurement_name: [[timestamp, value], ...]}\n        measurements_data = {\n            measurement_name: [\n                [int(timestamp.timestamp() * 1000), value]\n                for timestamp, value in self.measurements[measurement_name]\n            ]\n        }\n\n        message = json.dumps(measurements_data)\n\n        # Send to all connected clients\n        if self._websocket_loop is not None:\n            asyncio.run_coroutine_threadsafe(\n                self._broadcast_message(message),\n                self._websocket_loop\n            )\n\n        logger.debug(f\"Measurement '{measurement_name}' sent to {len(self._websocket_clients)} websocket clients\")\n\n    async def _broadcast_message(self, message: str):\n        \"\"\"Broadcast a message to all connected websocket clients.\n\n        :param message: The message to broadcast\n        \"\"\"\n        if self._websocket_clients:\n            disconnected_clients = set()\n            for client in self._websocket_clients:\n                try:\n                    await client.send(message)\n                except Exception as e:\n                    logger.warning(f\"Failed to send message to client: {e}\")\n                    disconnected_clients.add(client)\n\n            # Remove disconnected clients\n            self._websocket_clients -= disconnected_clients\n\n    async def _handle_websocket_client(self, websocket: WebSocketServerProtocol):\n        \"\"\"Handle a websocket client connection.\n\n        :param websocket: The websocket connection\n        \"\"\"\n        self._websocket_clients.add(websocket)\n        logger.info(f\"Websocket client connected. Total clients: {len(self._websocket_clients)}\")\n\n        try:\n            # Send all current measurements to the new client\n            all_measurements = {\n                name: [\n                    [timestamp.isoformat(), value]\n                    for timestamp, value in measurements\n                ]\n                for name, measurements in self.measurements.items()\n            }\n            if all_measurements:\n                await websocket.send(json.dumps(all_measurements))\n\n            # Keep connection alive and handle incoming messages\n            async for message in websocket:\n                logger.debug(f\"Received message from client: {message}\")\n        except Exception as e:\n            logger.warning(f\"Websocket client error: {e}\")\n        finally:\n            self._websocket_clients.discard(websocket)\n            logger.info(f\"Websocket client disconnected. Total clients: {len(self._websocket_clients)}\")\n\n    def _start_websocket_server(self):\n        \"\"\"Start the websocket server in a separate event loop.\"\"\"\n        async def run_server():\n            self._websocket_server = await websockets.serve(\n                self._handle_websocket_client,\n                \"localhost\",\n                self.output_socket_port\n            )\n            logger.info(f\"Websocket server started on port {self.output_socket_port}\")\n            if self._websocket_server is not None:\n                await self._websocket_server.wait_closed()\n            logger.info(\"Websocket server stopped\")\n\n        self._websocket_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._websocket_loop)\n        self._websocket_loop.run_until_complete(run_server())\n\n    def _stop_websocket_server(self):\n        \"\"\"Stop the websocket server.\"\"\"\n        if self._websocket_server is not None and self._websocket_loop is not None:\n            asyncio.run_coroutine_threadsafe(\n                self._websocket_server.close(),\n                self._websocket_loop\n            )\n            self._websocket_loop.call_soon_threadsafe(self._websocket_loop.stop)\n            if self._websocket_thread is not None:\n                self._websocket_thread.join(timeout=5)\n            self._websocket_thread = None\n            self._websocket_loop = None\n            self._websocket_server = None\n            logger.debug(\"Websocket server stopped\")\n\n    def reset_experiment(self):\n        \"\"\"Reset the experiment by clearing the actions, measurements and current time.\"\"\"\n        logger.debug(\"Experiment reset\")\n        if self._thread is not None:\n            logger.warning(\"Experiment is running. Stop it before resetting.\")\n            return\n\n        # Stop websocket server if running\n        if self.output_socket_port is not None:\n            self._stop_websocket_server()\n\n        self.actions.clear()\n        self.measurements.clear()\n        self.current_time = None\n        self._websocket_clients.clear()\n\n    def _validate_types(self, func: Callable, *args: Any, **kwargs: Any):\n        \"\"\"Validate that the arguments passed to the function are of the correct type.\n\n        :param func: The function to validate the arguments for\n        :param args: The positional arguments to validate\n        :param kwargs: The keyword arguments to validate\n\n        :raises TypeError: If any argument is not of the expected type according to the type hints of the function\n        \"\"\"\n        type_hints = get_type_hints(func)\n        sig = inspect.signature(func)\n        bound_arguments = sig.bind_partial(*args, **kwargs).arguments\n\n        for name, value in bound_arguments.items():\n            expected_type = type_hints.get(name)\n            if expected_type and not isinstance(value, expected_type):\n                msg = f\"Argument '{name}' is expected to be of type {expected_type}, but got {type(value)}\"\n                raise TypeError(msg)\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.__init__","title":"<code>__init__(output_dir=None, output_socket_port=None)</code>","text":"<p>Initialize the experiment with an empty list of actions and measurements</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def __init__(self, output_dir: os.PathLike | None = None, output_socket_port: int | None = None):\n    \"\"\"Initialize the experiment with an empty list of actions and measurements\"\"\"\n    self.actions: list[Action | WaitAction | ConditionalAction] = []\n    self.measurements: dict[str, list[tuple[datetime, Any]]] = defaultdict(list)\n    self.current_time: datetime | None = (\n        None  # Time to keep track of the experiment progress. Initializes on start.\n    )\n    self.output_dir = output_dir\n    self.output_socket_port = output_socket_port\n    self._thread: Thread | None = None\n    self._stop_event = Event()\n    self._websocket_clients: set[WebSocketServerProtocol] = set()\n    self._websocket_server = None\n    self._websocket_thread: Thread | None = None\n    self._websocket_loop: asyncio.AbstractEventLoop | None = None\n    logger.debug(\"Experiment created\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.create_metric","title":"<code>create_metric(measurement_name, statistic=Statistic.LAST())</code>","text":"<p>Create a metric object to be used in the experiment for making dynamic decisions.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_name</code> <code>str</code> <p>The name of the measurement in the experiment to use for the metric calculation</p> required <code>statistic</code> <code>Statistic | None</code> <p>The statistic to apply to the measurement values</p> <code>LAST()</code> <p>Returns:</p> Type Description <code>Metric</code> <p>The metric object</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def create_metric(self, measurement_name: str, statistic: Statistic | None = Statistic.LAST()) -&gt; Metric:\n    \"\"\"Create a metric object to be used in the experiment for making dynamic decisions.\n\n    :param measurement_name: The name of the measurement in the experiment to use for the metric calculation\n    :param statistic: The statistic to apply to the measurement values\n\n    :return: The metric object\n    \"\"\"\n    return Metric(self, measurement_name, statistic)\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.specify_output_dir","title":"<code>specify_output_dir(output_dir)</code>","text":"<p>Specify the output directory to write measurements to CSV files.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>PathLike</code> <p>The directory to write measurements to</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def specify_output_dir(self, output_dir: os.PathLike):\n    \"\"\"Specify the output directory to write measurements to CSV files.\n\n    :param output_dir: The directory to write measurements to\n    \"\"\"\n    self.output_dir = output_dir\n    logger.debug(f\"Output directory specified: {output_dir}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.specify_output_socket_port","title":"<code>specify_output_socket_port(port)</code>","text":"<p>Specify the output socket port to stream measurements via websocket.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port number to use for the websocket server</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def specify_output_socket_port(self, port: int):\n    \"\"\"Specify the output socket port to stream measurements via websocket.\n\n    :param port: The port number to use for the websocket server\n    \"\"\"\n    self.output_socket_port = port\n    logger.debug(f\"Output socket port specified: {port}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_action","title":"<code>add_action(func, condition=None, *args, **kwargs)</code>","text":"<p>Add an action to the experiment.</p> <p>The action will be executed in sequence when the experiment is run.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>condition</code> <code>Condition | None</code> <p>The condition to evaluate before executing the action</p> <code>None</code> <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_action(self, func: Callable, condition: Condition | None = None, *args: Any, **kwargs: Any):\n    \"\"\"Add an action to the experiment.\n\n    The action will be executed in sequence when the experiment is run.\n\n    :param func: The function to be executed\n    :param condition: The condition to evaluate before executing the action\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self._validate_types(func, *args, **kwargs)\n    action = Action(func, *args, **kwargs)\n    if condition is not None:\n        self.actions.append(ConditionalAction(action, condition))\n        logger.debug(f\"Conditional action added to experiment: {func.__name__} with condition: {condition}\")\n        return\n\n    self.actions.append(action)\n    logger.debug(f\"Action added to experiment: {func.__name__}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_measurement","title":"<code>add_measurement(func, measurement_name, condition=None, *args, **kwargs)</code>","text":"<p>Add a measurement to the experiment.</p> <p>The measurement will be executed in sequence when the experiment is run, and the result will be stored.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>measurement_name</code> <code>str</code> <p>The name of the measured value</p> required <code>condition</code> <code>Condition | None</code> <p>The condition to evaluate before executing the action</p> <code>None</code> <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_measurement(\n    self, func: Callable, measurement_name: str, condition: Condition | None = None, *args: Any, **kwargs: Any\n):\n    \"\"\"Add a measurement to the experiment.\n\n    The measurement will be executed in sequence when the experiment is run, and the result will be stored.\n\n    :param func: The function to be executed\n    :param measurement_name: The name of the measured value\n    :param condition: The condition to evaluate before executing the action\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self._validate_types(func, *args, **kwargs)\n    measurement = Measurement(func, measurement_name, *args, **kwargs)\n    if condition is not None:\n        self.actions.append(ConditionalAction(measurement, condition))\n        logger.debug(f\"Conditional measurement added to experiment: {func.__name__} with condition: {condition}\")\n        return\n\n    self.actions.append(measurement)\n    logger.debug(f\"Measurement added to experiment: {func.__name__}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_wait","title":"<code>add_wait(seconds, condition=None)</code>","text":"<p>Add a wait action to the experiment.</p> <p>The wait action will pause the execution of the experiment for the given amount of time.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds to wait</p> required <code>condition</code> <code>Condition | None</code> <p>The condition to evaluate before executing the action</p> <code>None</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_wait(self, seconds: float, condition: Condition | None = None):\n    \"\"\"Add a wait action to the experiment.\n\n    The wait action will pause the execution of the experiment for the given amount of time.\n\n    :param seconds: The number of seconds to wait\n    :param condition: The condition to evaluate before executing the action\n    \"\"\"\n    wait_action = WaitAction(seconds)\n    if condition is not None:\n        self.actions.append(ConditionalAction(wait_action, condition))\n        logger.debug(f\"Conditional wait added to experiment: {seconds} seconds with condition: {condition}\")\n        return\n\n    self.actions.append(wait_action)\n    logger.debug(f\"Wait action added to experiment: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.start","title":"<code>start(start_in_background=True)</code>","text":"<p>Start the experiment by running it in idle mode or in a separate thread depending on the <code>start_in_background</code> flag.</p> <p>Parameters:</p> Name Type Description Default <code>start_in_background</code> <code>bool</code> <p>If True, start the experiment in a separate thread. If False, run the experiment in the current thread. Be careful with this option, as it will block the current thread until the experiment is finished!</p> <code>True</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def start(self, start_in_background: bool = True):\n    \"\"\"Start the experiment by running it in idle mode or in a separate thread depending on the `start_in_background` flag.\n\n    :param start_in_background: If True, start the experiment in a separate thread.\n    If False, run the experiment in the current thread. Be careful with this option,\n    as it will block the current thread until the experiment is finished!\n    \"\"\"\n    if self._thread is not None:\n        logger.warning(\"Experiment is already running\")\n        return\n\n    self._stop_event.clear()\n\n    # Start websocket server if port is specified\n    if self.output_socket_port is not None:\n        self._websocket_thread = Thread(target=self._start_websocket_server, daemon=True)\n        self._websocket_thread.start()\n        # Give the websocket server a moment to start\n        time.sleep(0.5)\n\n    if start_in_background:\n        self._thread = Thread(target=self._run)\n        self._thread.start()\n    else:\n        self._run()\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.stop","title":"<code>stop()</code>","text":"<p>Stop the experiment by setting the stop event.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the experiment by setting the stop event.\"\"\"\n    if self._thread is None:\n        logger.warning(\"Experiment is not running\")\n        return\n    self._stop_event.set()\n    logger.info(\"Experiment stop signal sent\")\n\n    # Stop websocket server\n    if self.output_socket_port is not None:\n        self._stop_websocket_server()\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.write_measurement_to_csv","title":"<code>write_measurement_to_csv(measurement_name)</code>","text":"<p>Write last acquired measurement to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_name</code> <code>str</code> <p>The name of the measurement to write to a CSV file</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def write_measurement_to_csv(self, measurement_name: str):\n    \"\"\"Write last acquired measurement to a CSV file.\n\n    :param measurement_name: The name of the measurement to write to a CSV file\n    \"\"\"\n    if self.output_dir is None:\n        return\n\n    if measurement_name not in self.measurements:\n        raise ValueError(f\"Measurement '{measurement_name}' not found\")\n\n    output_file = os.path.join(self.output_dir, f\"{measurement_name}.csv\")\n    with open(output_file, \"a\") as f:\n        timestamp, value = self.measurements[measurement_name][-1]\n        f.write(f\"{timestamp},{value}\\n\")\n\n    logger.debug(f\"Measurement '{measurement_name}' written to {output_file}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.write_measurements_to_socket","title":"<code>write_measurements_to_socket(measurement_name)</code>","text":"<p>Write all acquired measurements to a websocket.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_name</code> <code>str</code> <p>The name of the measurement to write to a websocket</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def write_measurements_to_socket(self, measurement_name: str):\n    \"\"\"Write all acquired measurements to a websocket.\n\n    :param measurement_name: The name of the measurement to write to a websocket\n    \"\"\"\n    if self.output_socket_port is None:\n        return\n\n    if not self._websocket_clients:\n        return\n\n    # Format measurements as requested: {measurement_name: [[timestamp, value], ...]}\n    measurements_data = {\n        measurement_name: [\n            [int(timestamp.timestamp() * 1000), value]\n            for timestamp, value in self.measurements[measurement_name]\n        ]\n    }\n\n    message = json.dumps(measurements_data)\n\n    # Send to all connected clients\n    if self._websocket_loop is not None:\n        asyncio.run_coroutine_threadsafe(\n            self._broadcast_message(message),\n            self._websocket_loop\n        )\n\n    logger.debug(f\"Measurement '{measurement_name}' sent to {len(self._websocket_clients)} websocket clients\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.reset_experiment","title":"<code>reset_experiment()</code>","text":"<p>Reset the experiment by clearing the actions, measurements and current time.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def reset_experiment(self):\n    \"\"\"Reset the experiment by clearing the actions, measurements and current time.\"\"\"\n    logger.debug(\"Experiment reset\")\n    if self._thread is not None:\n        logger.warning(\"Experiment is running. Stop it before resetting.\")\n        return\n\n    # Stop websocket server if running\n    if self.output_socket_port is not None:\n        self._stop_websocket_server()\n\n    self.actions.clear()\n    self.measurements.clear()\n    self.current_time = None\n    self._websocket_clients.clear()\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>This module provides the interfaces for hardware devices that can be controlled by the BioExperiment Suite. Using these interfaces, you can interact with the devices in a standardized way, regardless of the specific hardware implementation.</p>"},{"location":"api/interfaces/pump/","title":"Pump","text":""},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump","title":"<code>Pump</code>","text":"<p>               Bases: <code>SerialConnection</code></p> <p>Class to handle communication with a pump connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>class Pump(SerialConnection):\n    \"\"\"Class to handle communication with a pump connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n        \"\"\"Initializes the pump object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n        \"\"\"\n        self.interface = device_interfaces.pump\n        self.default_flow_rate: int | float | None = None\n        super(Pump, self).__init__(port, baudrate, timeout_sec)\n        self._compute_calibration_volume()\n\n    def _compute_calibration_volume(self) -&gt; None:\n        \"\"\"Computes the calibration volume of the pump.\"\"\"\n\n        if get_settings().EMULATE_DEVICES:\n            self._calibration_volume = 1.0\n            logger.debug(f\"FAKE calibration volume computed: {self._calibration_volume:.3f}\")\n            return\n\n        identification_response = self.communicate_with_serial_port(\n            self.interface.identification_signal,\n            self.interface.identification_response_len,\n        )\n        self._calibration_volume = self._bytes_to_int(identification_response[1:]) / 10**5\n        logger.debug(f\"Calibration volume computed: {self._calibration_volume:.3f}\")\n\n    def _compute_speed_param_from_flow(self, flow: int | float) -&gt; int:\n        \"\"\"Computes the speed parameter from the real speed of the pump.\n\n        :param flow: The real flow rate of the pump in mL/min\n\n        :returns: The speed parameter to send to the pump\n        \"\"\"\n\n        speed_param = int(29 / flow)\n        return speed_param\n\n    def _compute_step_volume_bytes(self, volume: int | float) -&gt; list[int]:\n        \"\"\"Computes the step volume in bytes to send to the pump.\n\n        :param volume: The volume to set in mL\n\n        :returns: The byte representation of the volume\n        \"\"\"\n        step_volume = int((volume * 10**4) / self._calibration_volume)\n        step_volume_bytes = self._int_to_bytes(step_volume, 4)\n        return step_volume_bytes\n\n    def set_default_flow_rate(self, flow_rate: int | float):\n        \"\"\"Sets the default flow rate of the pump.\n\n        :param flow_rate: The flow rate to set in mL/min\n        \"\"\"\n        self.default_flow_rate = flow_rate\n\n    def _set_flow_rate(self, flow_rate: int | float):\n        \"\"\"Sets the flow rate of the pump before pouring in volume.\n\n        :param flow_rate: The flow rate to set in mL/min\n        \"\"\"\n        logger.debug(f\"Setting flow rate to {flow_rate:.3f} mL/min\")\n        speed_param = self._compute_speed_param_from_flow(flow_rate)\n        data_to_send = [10, 0, 1, speed_param, 0]\n        self.write_to_serial_port(data_to_send)\n\n    def pour_in_volume(\n        self,\n        volume: int | float,\n        flow_rate: int | float | None = None,\n        direction: str = \"left\",\n        blocking_mode: bool = True,\n        info_log_message: str | None = None,\n        info_log_level: str = \"INFO\",\n    ):\n        \"\"\"Pours in the specified volume of liquid.\n\n        :param volume: The volume to pour in mL\n        :param flow_rate: The flow rate of the pump in mL/min\n        :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n        :param blocking_mode: Whether to wait for the pump to finish pouring in the volume. Defaults to True\n        \"\"\"\n\n        assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n        direction_byte = 16 if direction == \"left\" else 17\n\n        flow_rate = flow_rate or self.default_flow_rate\n        if flow_rate is None:\n            raise ValueError(\"Flow rate must be set before pouring in volume or passed as an argument\")\n        self._set_flow_rate(flow_rate)  # type: ignore\n\n        logger.debug(f\"Pouring in {volume:.3f} mL at flow rate {flow_rate:.3f} mL/min\")\n        if info_log_message:\n            logger.log(info_log_level, info_log_message)\n\n        data_to_send = [direction_byte] + self._compute_step_volume_bytes(volume)\n        self.write_to_serial_port(data_to_send)\n\n        if blocking_mode:\n            sleep_time = (volume / flow_rate) * 60\n            sleep(sleep_time + UNACCOUNTED_FOR_TIME_SEC)\n\n    def start_continuous_rotation(self, flow_rate: int | float | None = None, direction: str = \"left\"):\n        \"\"\"Starts the continuous rotation of the pump.\n\n        :param flow_rate: The flow rate of the pump in mL/min\n        :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n        \"\"\"\n\n        assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n        direction_byte = 11 if direction == \"left\" else 12\n\n        if flow_rate is None and self.default_flow_rate is None:\n            raise ValueError(\"Flow rate must be set before starting continuous rotation or passed as an argument\")\n\n        flow_rate = flow_rate or self.default_flow_rate\n\n        logger.debug(f\"Starting continuous rotation at flow rate {flow_rate:.3f} mL/min\")\n        speed_param = self._compute_speed_param_from_flow(flow_rate)  # type: ignore\n\n        data_to_send = [direction_byte, 111, 1, speed_param, 0]\n        self.write_to_serial_port(data_to_send)\n\n    def stop_continuous_rotation(self):\n        \"\"\"Stops the continuous rotation of the pump\"\"\"\n        logger.debug(\"Stopping continuous rotation\")\n        self.pour_in_volume(0)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the pump object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>int | float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n    \"\"\"Initializes the pump object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n    \"\"\"\n    self.interface = device_interfaces.pump\n    self.default_flow_rate: int | float | None = None\n    super(Pump, self).__init__(port, baudrate, timeout_sec)\n    self._compute_calibration_volume()\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.set_default_flow_rate","title":"<code>set_default_flow_rate(flow_rate)</code>","text":"<p>Sets the default flow rate of the pump.</p> <p>Parameters:</p> Name Type Description Default <code>flow_rate</code> <code>int | float</code> <p>The flow rate to set in mL/min</p> required Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def set_default_flow_rate(self, flow_rate: int | float):\n    \"\"\"Sets the default flow rate of the pump.\n\n    :param flow_rate: The flow rate to set in mL/min\n    \"\"\"\n    self.default_flow_rate = flow_rate\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.pour_in_volume","title":"<code>pour_in_volume(volume, flow_rate=None, direction='left', blocking_mode=True, info_log_message=None, info_log_level='INFO')</code>","text":"<p>Pours in the specified volume of liquid.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>int | float</code> <p>The volume to pour in mL</p> required <code>flow_rate</code> <code>int | float | None</code> <p>The flow rate of the pump in mL/min</p> <code>None</code> <code>direction</code> <code>str</code> <p>The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"</p> <code>'left'</code> <code>blocking_mode</code> <code>bool</code> <p>Whether to wait for the pump to finish pouring in the volume. Defaults to True</p> <code>True</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def pour_in_volume(\n    self,\n    volume: int | float,\n    flow_rate: int | float | None = None,\n    direction: str = \"left\",\n    blocking_mode: bool = True,\n    info_log_message: str | None = None,\n    info_log_level: str = \"INFO\",\n):\n    \"\"\"Pours in the specified volume of liquid.\n\n    :param volume: The volume to pour in mL\n    :param flow_rate: The flow rate of the pump in mL/min\n    :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n    :param blocking_mode: Whether to wait for the pump to finish pouring in the volume. Defaults to True\n    \"\"\"\n\n    assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n    direction_byte = 16 if direction == \"left\" else 17\n\n    flow_rate = flow_rate or self.default_flow_rate\n    if flow_rate is None:\n        raise ValueError(\"Flow rate must be set before pouring in volume or passed as an argument\")\n    self._set_flow_rate(flow_rate)  # type: ignore\n\n    logger.debug(f\"Pouring in {volume:.3f} mL at flow rate {flow_rate:.3f} mL/min\")\n    if info_log_message:\n        logger.log(info_log_level, info_log_message)\n\n    data_to_send = [direction_byte] + self._compute_step_volume_bytes(volume)\n    self.write_to_serial_port(data_to_send)\n\n    if blocking_mode:\n        sleep_time = (volume / flow_rate) * 60\n        sleep(sleep_time + UNACCOUNTED_FOR_TIME_SEC)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.start_continuous_rotation","title":"<code>start_continuous_rotation(flow_rate=None, direction='left')</code>","text":"<p>Starts the continuous rotation of the pump.</p> <p>Parameters:</p> Name Type Description Default <code>flow_rate</code> <code>int | float | None</code> <p>The flow rate of the pump in mL/min</p> <code>None</code> <code>direction</code> <code>str</code> <p>The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"</p> <code>'left'</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def start_continuous_rotation(self, flow_rate: int | float | None = None, direction: str = \"left\"):\n    \"\"\"Starts the continuous rotation of the pump.\n\n    :param flow_rate: The flow rate of the pump in mL/min\n    :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n    \"\"\"\n\n    assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n    direction_byte = 11 if direction == \"left\" else 12\n\n    if flow_rate is None and self.default_flow_rate is None:\n        raise ValueError(\"Flow rate must be set before starting continuous rotation or passed as an argument\")\n\n    flow_rate = flow_rate or self.default_flow_rate\n\n    logger.debug(f\"Starting continuous rotation at flow rate {flow_rate:.3f} mL/min\")\n    speed_param = self._compute_speed_param_from_flow(flow_rate)  # type: ignore\n\n    data_to_send = [direction_byte, 111, 1, speed_param, 0]\n    self.write_to_serial_port(data_to_send)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.stop_continuous_rotation","title":"<code>stop_continuous_rotation()</code>","text":"<p>Stops the continuous rotation of the pump</p> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def stop_continuous_rotation(self):\n    \"\"\"Stops the continuous rotation of the pump\"\"\"\n    logger.debug(\"Stopping continuous rotation\")\n    self.pour_in_volume(0)\n</code></pre>"},{"location":"api/interfaces/serial_connection/","title":"Serial Connection","text":""},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection","title":"<code>SerialConnection</code>","text":"<p>Class to handle serial communication with a device connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>class SerialConnection:\n    \"\"\"Class to handle serial communication with a device connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: float = 1.0):\n        \"\"\"Initializes the serial connection object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n\n        :raises serial.SerialException: If the serial connection cannot be established\n        \"\"\"\n        self.port = port\n        self.baudrate = baudrate\n        self.timeout_sec = timeout_sec\n        self._create_serial_connection()\n\n    def _create_serial_connection(self) -&gt; None:\n        \"\"\"Creates a serial connection with the specified parameters.\"\"\"\n\n        if get_settings().EMULATE_DEVICES:\n            logger.info(f\"FAKE serial connection established with {self.port}\")\n            sleep(1)\n            return\n\n        self.serial = serial.Serial(self.port, self.baudrate, timeout=self.timeout_sec)\n        logger.info(f\"Serial connection established with {self.port}\")\n        sleep(3)\n\n    @staticmethod\n    def _restore_connection(method: Callable) -&gt; Callable:\n        \"\"\"Decorator to restore the serial connection if it is lost during communication.\n\n        :param method: The method to decorate\n\n        :returns: The decorated method\n        \"\"\"\n\n        @wraps(method)\n        def wrapper(self: SerialConnection, *args, **kwargs):\n            try:\n                return method(self, *args, **kwargs)\n            except serial.SerialException:\n                logger.warning(f\"Serial connection lost on port {self.port}. Restoring connection...\")\n                self._create_serial_connection()\n                return method(self, *args, **kwargs)\n\n        return wrapper\n\n    @_restore_connection\n    def write_to_serial_port(self, data_to_send: list[int]) -&gt; None:\n        \"\"\"Writes data to the serial port.\n\n        :param data_to_send: The data to send to the serial port\n        \"\"\"\n        if get_settings().EMULATE_DEVICES:\n            logger.debug(f\"Data sent to FAKE serial port: {data_to_send}\")\n            return\n\n        bytes_to_send = bytes(data_to_send)\n        self.serial.write(bytes_to_send)\n        logger.debug(f\"Data sent to serial port: {data_to_send}\")\n\n    @_restore_connection\n    def read_from_serial_port(self, response_bytes: int) -&gt; bytes:\n        \"\"\"Reads data from the serial port.\n\n        :param response_bytes: The number of bytes to read from the serial port\n\n        :returns: The response from the serial port\n        \"\"\"\n        if get_settings().EMULATE_DEVICES:\n            response = bytes([0x00] * response_bytes)\n            logger.debug(f\"Data received from FAKE serial port: {list(response)}\")\n            return response\n\n        response = self.serial.read(response_bytes)\n        logger.debug(f\"Data received from serial port: {list(response)}\")\n        return response\n\n    def communicate_with_serial_port(self, data_to_send: list[int], response_bytes: int) -&gt; bytes:\n        \"\"\"Communicates with the serial port by sending data and receiving a response.\n\n        :param data_to_send: The data to send to the serial port\n        :param response_bytes: The number of bytes to read from the serial port as a response\n\n        :returns: The response from the serial port\n        \"\"\"\n        self.write_to_serial_port(data_to_send)\n        response = self.read_from_serial_port(response_bytes)\n        return response\n\n    def _bytes_to_int(self, bytes_: bytes) -&gt; int:\n        \"\"\"Converts a byte array to an integer.\n\n        :param bytes_: The byte array to convert to an integer\n\n        :returns: The integer representation of the byte array\n        \"\"\"\n        return int.from_bytes(bytes_, byteorder=\"big\")\n\n    def _int_to_bytes(self, integer: int, n_bytes: int | None = None) -&gt; list[int]:\n        \"\"\"Converts an integer to a byte array.\n\n        :param integer: The integer to convert to a byte array\n        :param n_bytes: The number of bytes to represent the integer. Defaults to None.\n\n        :returns: The byte array representation of the integer\n        \"\"\"\n        if n_bytes is None:\n            n_bytes = (integer.bit_length() + 7) // 8\n\n        byte_representation = integer.to_bytes(n_bytes, byteorder=\"big\")\n        return list(byte_representation)\n\n    def __del__(self):\n        \"\"\"Closes the serial connection when the object is deleted.\"\"\"\n        if get_settings().EMULATE_DEVICES:\n            logger.debug(f\"Closing FAKE serial connection with {self.port}\")\n            return\n\n        logger.debug(f\"Closing serial connection with {self.port}\")\n        self.serial.close()\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the serial connection object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> <p>Raises:</p> Type Description <code>serial.SerialException</code> <p>If the serial connection cannot be established</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: float = 1.0):\n    \"\"\"Initializes the serial connection object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n\n    :raises serial.SerialException: If the serial connection cannot be established\n    \"\"\"\n    self.port = port\n    self.baudrate = baudrate\n    self.timeout_sec = timeout_sec\n    self._create_serial_connection()\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.write_to_serial_port","title":"<code>write_to_serial_port(data_to_send)</code>","text":"<p>Writes data to the serial port.</p> <p>Parameters:</p> Name Type Description Default <code>data_to_send</code> <code>list[int]</code> <p>The data to send to the serial port</p> required Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>@_restore_connection\ndef write_to_serial_port(self, data_to_send: list[int]) -&gt; None:\n    \"\"\"Writes data to the serial port.\n\n    :param data_to_send: The data to send to the serial port\n    \"\"\"\n    if get_settings().EMULATE_DEVICES:\n        logger.debug(f\"Data sent to FAKE serial port: {data_to_send}\")\n        return\n\n    bytes_to_send = bytes(data_to_send)\n    self.serial.write(bytes_to_send)\n    logger.debug(f\"Data sent to serial port: {data_to_send}\")\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.read_from_serial_port","title":"<code>read_from_serial_port(response_bytes)</code>","text":"<p>Reads data from the serial port.</p> <p>Parameters:</p> Name Type Description Default <code>response_bytes</code> <code>int</code> <p>The number of bytes to read from the serial port</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response from the serial port</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>@_restore_connection\ndef read_from_serial_port(self, response_bytes: int) -&gt; bytes:\n    \"\"\"Reads data from the serial port.\n\n    :param response_bytes: The number of bytes to read from the serial port\n\n    :returns: The response from the serial port\n    \"\"\"\n    if get_settings().EMULATE_DEVICES:\n        response = bytes([0x00] * response_bytes)\n        logger.debug(f\"Data received from FAKE serial port: {list(response)}\")\n        return response\n\n    response = self.serial.read(response_bytes)\n    logger.debug(f\"Data received from serial port: {list(response)}\")\n    return response\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.communicate_with_serial_port","title":"<code>communicate_with_serial_port(data_to_send, response_bytes)</code>","text":"<p>Communicates with the serial port by sending data and receiving a response.</p> <p>Parameters:</p> Name Type Description Default <code>data_to_send</code> <code>list[int]</code> <p>The data to send to the serial port</p> required <code>response_bytes</code> <code>int</code> <p>The number of bytes to read from the serial port as a response</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response from the serial port</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def communicate_with_serial_port(self, data_to_send: list[int], response_bytes: int) -&gt; bytes:\n    \"\"\"Communicates with the serial port by sending data and receiving a response.\n\n    :param data_to_send: The data to send to the serial port\n    :param response_bytes: The number of bytes to read from the serial port as a response\n\n    :returns: The response from the serial port\n    \"\"\"\n    self.write_to_serial_port(data_to_send)\n    response = self.read_from_serial_port(response_bytes)\n    return response\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.__del__","title":"<code>__del__()</code>","text":"<p>Closes the serial connection when the object is deleted.</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def __del__(self):\n    \"\"\"Closes the serial connection when the object is deleted.\"\"\"\n    if get_settings().EMULATE_DEVICES:\n        logger.debug(f\"Closing FAKE serial connection with {self.port}\")\n        return\n\n    logger.debug(f\"Closing serial connection with {self.port}\")\n    self.serial.close()\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/","title":"Spectrophotometer","text":""},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer","title":"<code>Spectrophotometer</code>","text":"<p>               Bases: <code>SerialConnection</code></p> <p>Class to handle communication with a spectrophotometer connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>class Spectrophotometer(SerialConnection):\n    \"\"\"Class to handle communication with a spectrophotometer connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n        \"\"\"Initializes the spectrophotometer object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n        \"\"\"\n        self.interface = device_interfaces.spectrophotometer\n        super(Spectrophotometer, self).__init__(port, baudrate, timeout_sec)\n\n    def get_temperature(self) -&gt; float:\n        \"\"\"Gets the temperature of the spectrophotometer\n\n        :returns: The temperature in degrees Celsius\n        \"\"\"\n\n        if get_settings().EMULATE_DEVICES:\n            logger.debug(\"Getting FAKE temperature\")\n            temperature = random() * 10 + 20\n            logger.debug(f\"FAKE temperature: {temperature:.2f}\")\n            return temperature\n\n        logger.debug(\"Getting temperature\")\n        temperature_response = self.communicate_with_serial_port(\n            self.interface.commands.get_temperature.request,\n            self.interface.commands.get_temperature.response_len,\n        )\n        logger.debug(f\"Temperature response: {list(temperature_response)}\")\n        integer, fractional = temperature_response[2:]\n        temperature = integer + (fractional / 100)\n        logger.debug(f\"Temperature: {temperature:.2f}\")\n        return temperature\n\n    def _send_start_measurement_command(self):\n        \"\"\"Sends the command to start the measurement.\"\"\"\n        self.write_to_serial_port(self.interface.commands.start_measurement.request)\n        logger.debug(\"Start measurement command sent\")\n\n    def _get_optical_density(self) -&gt; float | None:\n        \"\"\"Gets the optical density of the sample.\n\n        :returns: The optical density of the sample\n        \"\"\"\n\n        if get_settings().EMULATE_DEVICES:\n            logger.debug(\"Getting FAKE optical density\")\n            optical_density = random()\n            logger.debug(f\"Fake optical density: {optical_density:.5f}\")\n            return optical_density\n\n        optical_density_response = self.communicate_with_serial_port(\n            self.interface.commands.get_measurement_result.request,\n            self.interface.commands.get_measurement_result.response_len,\n        )\n        logger.debug(f\"Optical density response: {list(optical_density_response)}\")\n        if not optical_density_response:\n            return None\n        integer, fractional = optical_density_response[2:]\n        optical_density = integer + (fractional / 100)\n        logger.debug(f\"Optical density: {optical_density:.5f}\")\n        return optical_density\n\n    def measure_optical_density(self) -&gt; float:\n        \"\"\"Measures the optical density of the sample.\n\n        :returns: The optical density of the sample\n        \"\"\"\n        logger.debug(\"Measuring optical density\")\n        self._send_start_measurement_command()\n        logger.debug(\"Optical density not ready yet, waiting...\")\n        sleep(3 if not get_settings().EMULATE_DEVICES else 1)\n        optical_density = self._get_optical_density()\n        if optical_density is None:\n            logger.error(\"Optical density could not be measured\")\n            raise Exception(\"Optical density could not be measured\")\n\n        return optical_density\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the spectrophotometer object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>int | float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n    \"\"\"Initializes the spectrophotometer object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n    \"\"\"\n    self.interface = device_interfaces.spectrophotometer\n    super(Spectrophotometer, self).__init__(port, baudrate, timeout_sec)\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.get_temperature","title":"<code>get_temperature()</code>","text":"<p>Gets the temperature of the spectrophotometer</p> <p>Returns:</p> Type Description <code>float</code> <p>The temperature in degrees Celsius</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def get_temperature(self) -&gt; float:\n    \"\"\"Gets the temperature of the spectrophotometer\n\n    :returns: The temperature in degrees Celsius\n    \"\"\"\n\n    if get_settings().EMULATE_DEVICES:\n        logger.debug(\"Getting FAKE temperature\")\n        temperature = random() * 10 + 20\n        logger.debug(f\"FAKE temperature: {temperature:.2f}\")\n        return temperature\n\n    logger.debug(\"Getting temperature\")\n    temperature_response = self.communicate_with_serial_port(\n        self.interface.commands.get_temperature.request,\n        self.interface.commands.get_temperature.response_len,\n    )\n    logger.debug(f\"Temperature response: {list(temperature_response)}\")\n    integer, fractional = temperature_response[2:]\n    temperature = integer + (fractional / 100)\n    logger.debug(f\"Temperature: {temperature:.2f}\")\n    return temperature\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.measure_optical_density","title":"<code>measure_optical_density()</code>","text":"<p>Measures the optical density of the sample.</p> <p>Returns:</p> Type Description <code>float</code> <p>The optical density of the sample</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def measure_optical_density(self) -&gt; float:\n    \"\"\"Measures the optical density of the sample.\n\n    :returns: The optical density of the sample\n    \"\"\"\n    logger.debug(\"Measuring optical density\")\n    self._send_start_measurement_command()\n    logger.debug(\"Optical density not ready yet, waiting...\")\n    sleep(3 if not get_settings().EMULATE_DEVICES else 1)\n    optical_density = self._get_optical_density()\n    if optical_density is None:\n        logger.error(\"Optical density could not be measured\")\n        raise Exception(\"Optical density could not be measured\")\n\n    return optical_density\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>This is a collection of examples that demonstrate how to use the various features of the BioExperiment Suite. It will guide you through the process of using the API to perform common tasks in such order:</p>"}]}